//
//  StyleKit.swift
//  Smartime
//
//  Created by Ricardo Pereira on 07/06/2015.
//  Copyright (c) 2015 . All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//



import UIKit

public class StyleKit : NSObject {

    //// Cache

    private struct Cache {
        static var blueInit: UIColor = UIColor(red: 0.239, green: 0.329, blue: 0.863, alpha: 1.000)
        static var blueFinal: UIColor = UIColor(red: 0.000, green: 0.725, blue: 0.863, alpha: 1.000)
        static var rockBlue: UIColor = UIColor(red: 0.596, green: 0.722, blue: 0.804, alpha: 1.000)
        static var lightSky: UIColor = UIColor(red: 0.584, green: 0.776, blue: 0.984, alpha: 1.000)
        static var cloudBurst: UIColor = UIColor(red: 0.220, green: 0.243, blue: 0.314, alpha: 1.000)
        static var noteBlue: UIColor = UIColor(red: 0.934, green: 0.966, blue: 1.000, alpha: 1.000)
        static var blueGradient: CGGradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [StyleKit.blueInit.CGColor, StyleKit.blueInit.blendedColorWithFraction(0.5, ofColor: StyleKit.blueFinal).CGColor, StyleKit.blueFinal.CGColor], [0, 0.34, 1])
        static var shadow: NSShadow = NSShadow(color: UIColor.blackColor().colorWithAlphaComponent(0.6), offset: CGSizeMake(0.1, 12.1), blurRadius: 15)
        static var imageOfLogo: UIImage?
        static var logoTargets: [AnyObject]?
        static var imageOfNext: UIImage?
        static var nextTargets: [AnyObject]?
    }

    //// Colors

    public class var blueInit: UIColor { return Cache.blueInit }
    public class var blueFinal: UIColor { return Cache.blueFinal }
    public class var rockBlue: UIColor { return Cache.rockBlue }
    public class var lightSky: UIColor { return Cache.lightSky }
    public class var cloudBurst: UIColor { return Cache.cloudBurst }
    public class var noteBlue: UIColor { return Cache.noteBlue }

    //// Gradients

    public class var blueGradient: CGGradient { return Cache.blueGradient }

    //// Shadows

    public class var shadow: NSShadow { return Cache.shadow }

    //// Drawing Methods

    public class func drawLogo() {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// timer_L Drawing
        var timer_LPath = UIBezierPath()
        timer_LPath.moveToPoint(CGPointMake(45.07, 53.3))
        timer_LPath.addCurveToPoint(CGPointMake(45.34, 53.57), controlPoint1: CGPointMake(45.15, 53.4), controlPoint2: CGPointMake(45.26, 53.48))
        timer_LPath.addCurveToPoint(CGPointMake(50, 55.83), controlPoint1: CGPointMake(46.45, 54.94), controlPoint2: CGPointMake(48.11, 55.83))
        timer_LPath.addCurveToPoint(CGPointMake(56, 49.83), controlPoint1: CGPointMake(53.31, 55.83), controlPoint2: CGPointMake(56, 53.15))
        timer_LPath.addCurveToPoint(CGPointMake(54.02, 45.4), controlPoint1: CGPointMake(56, 48.06), controlPoint2: CGPointMake(55.23, 46.5))
        timer_LPath.addCurveToPoint(CGPointMake(53.49, 44.87), controlPoint1: CGPointMake(53.87, 45.23), controlPoint2: CGPointMake(53.72, 45.05))
        timer_LPath.addLineToPoint(CGPointMake(29.25, 26.42))
        timer_LPath.addCurveToPoint(CGPointMake(26.79, 26.42), controlPoint1: CGPointMake(28.54, 25.88), controlPoint2: CGPointMake(27.52, 25.85))
        timer_LPath.addCurveToPoint(CGPointMake(26.42, 29.25), controlPoint1: CGPointMake(25.9, 27.1), controlPoint2: CGPointMake(25.74, 28.37))
        timer_LPath.addLineToPoint(CGPointMake(45.07, 53.3))
        timer_LPath.closePath()
        timer_LPath.moveToPoint(CGPointMake(50, -0))
        timer_LPath.addCurveToPoint(CGPointMake(48.06, 0.1), controlPoint1: CGPointMake(49.34, -0), controlPoint2: CGPointMake(48.7, 0.07))
        timer_LPath.addLineToPoint(CGPointMake(48.06, 2.17))
        timer_LPath.addLineToPoint(CGPointMake(48, 2.17))
        timer_LPath.addLineToPoint(CGPointMake(48, 23.99))
        timer_LPath.addLineToPoint(CGPointMake(52, 23.99))
        timer_LPath.addLineToPoint(CGPointMake(52, 4.1))
        timer_LPath.addCurveToPoint(CGPointMake(96, 50), controlPoint1: CGPointMake(76.44, 5.16), controlPoint2: CGPointMake(96, 25.31))
        timer_LPath.addCurveToPoint(CGPointMake(50, 96), controlPoint1: CGPointMake(96, 75.37), controlPoint2: CGPointMake(75.37, 96))
        timer_LPath.addCurveToPoint(CGPointMake(4, 50), controlPoint1: CGPointMake(24.63, 96), controlPoint2: CGPointMake(4, 75.37))
        timer_LPath.addCurveToPoint(CGPointMake(17.49, 17.49), controlPoint1: CGPointMake(4, 37.32), controlPoint2: CGPointMake(9.16, 25.82))
        timer_LPath.addLineToPoint(CGPointMake(14.65, 14.64))
        timer_LPath.addCurveToPoint(CGPointMake(0, 50), controlPoint1: CGPointMake(5.6, 23.69), controlPoint2: CGPointMake(0, 36.19))
        timer_LPath.addCurveToPoint(CGPointMake(50, 100), controlPoint1: CGPointMake(0, 77.62), controlPoint2: CGPointMake(22.38, 100))
        timer_LPath.addCurveToPoint(CGPointMake(100, 50), controlPoint1: CGPointMake(77.62, 100), controlPoint2: CGPointMake(100, 77.62))
        timer_LPath.addCurveToPoint(CGPointMake(50, -0), controlPoint1: CGPointMake(100, 22.39), controlPoint2: CGPointMake(77.62, -0))
        timer_LPath.closePath()
        timer_LPath.miterLimit = 4;

        timer_LPath.usesEvenOddFillRule = true;

        CGContextSaveGState(context)
        timer_LPath.addClip()
        CGContextDrawLinearGradient(context, StyleKit.blueGradient,
            CGPointMake(28.89, 28.89),
            CGPointMake(61.46, 71.11),
            UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
        CGContextRestoreGState(context)
    }

    public class func drawNext() {

        //// Oval Drawing
        var ovalPath = UIBezierPath(ovalInRect: CGRectMake(0, 0, 50, 50))
        StyleKit.lightSky.setFill()
        ovalPath.fill()


        //// Bezier Drawing
        var bezierPath = UIBezierPath()
        bezierPath.moveToPoint(CGPointMake(21.5, 15.5))
        bezierPath.addCurveToPoint(CGPointMake(29.5, 24.5), controlPoint1: CGPointMake(29.44, 24.43), controlPoint2: CGPointMake(29.5, 24.5))
        bezierPath.addLineToPoint(CGPointMake(21.5, 33.5))
        StyleKit.cloudBurst.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()
    }

    public class func drawShadowTest(#frame: CGRect) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRectMake(frame.minX, frame.minY, frame.width, frame.height))
        StyleKit.cloudBurst.setFill()
        rectanglePath.fill()

        ////// Rectangle Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, rectanglePath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((StyleKit.shadow.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let rectangleOpaqueShadow = (StyleKit.shadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, StyleKit.shadow.shadowOffset, StyleKit.shadow.shadowBlurRadius, rectangleOpaqueShadow.CGColor)
        CGContextSetBlendMode(context, kCGBlendModeSourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        rectangleOpaqueShadow.setFill()
        rectanglePath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    //// Generated Images

    public class var imageOfLogo: UIImage {
        if Cache.imageOfLogo != nil {
            return Cache.imageOfLogo!
        }

        UIGraphicsBeginImageContextWithOptions(CGSizeMake(100, 100), false, 0)
            StyleKit.drawLogo()

        Cache.imageOfLogo = UIGraphicsGetImageFromCurrentImageContext()!.imageWithRenderingMode(UIImageRenderingMode.AlwaysOriginal)
        UIGraphicsEndImageContext()

        return Cache.imageOfLogo!
    }

    public class var imageOfNext: UIImage {
        if Cache.imageOfNext != nil {
            return Cache.imageOfNext!
        }

        UIGraphicsBeginImageContextWithOptions(CGSizeMake(50, 50), false, 0)
            StyleKit.drawNext()

        Cache.imageOfNext = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfNext!
    }

    //// Customization Infrastructure

    @IBOutlet var logoTargets: [AnyObject]! {
        get { return Cache.logoTargets }
        set {
            Cache.logoTargets = newValue
            for target: AnyObject in newValue {
                target.setImage(StyleKit.imageOfLogo)
            }
        }
    }

    @IBOutlet var nextTargets: [AnyObject]! {
        get { return Cache.nextTargets }
        set {
            Cache.nextTargets = newValue
            for target: AnyObject in newValue {
                target.setImage(StyleKit.imageOfNext)
            }
        }
    }

}



extension UIColor {
    func blendedColorWithFraction(fraction: CGFloat, ofColor color: UIColor) -> UIColor {
        var r1: CGFloat = 1.0, g1: CGFloat = 1.0, b1: CGFloat = 1.0, a1: CGFloat = 1.0
        var r2: CGFloat = 1.0, g2: CGFloat = 1.0, b2: CGFloat = 1.0, a2: CGFloat = 1.0

        self.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)

        return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
            green: g1 * (1 - fraction) + g2 * fraction,
            blue: b1 * (1 - fraction) + b2 * fraction,
            alpha: a1 * (1 - fraction) + a2 * fraction);
    }
}



extension NSShadow {
    convenience init(color: AnyObject!, offset: CGSize, blurRadius: CGFloat) {
        self.init()
        self.shadowColor = color
        self.shadowOffset = offset
        self.shadowBlurRadius = blurRadius
    }
}

@objc protocol StyleKitSettableImage {
    func setImage(image: UIImage!)
}

@objc protocol StyleKitSettableSelectedImage {
    func setSelectedImage(image: UIImage!)
}
